<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>Chain Reaction Game</title>
  <style>
    body {
      background: #222;
      color: #fff;
      font-family: Arial, sans-serif;
      text-align: center;
      margin: 0;
      padding: 0;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      height: 100vh;
    }
    #info {
      margin-bottom: 10px;
      font-size: 20px;
    }
    canvas {
      background: #333;
      border: 2px solid #555;
    }
  </style>
</head>
<body>
  <!-- Displays the current player turn -->
  <div id="info">Current Turn: Player 1</div>
  <!-- The game board will be drawn on this canvas -->
  <canvas id="boardCanvas"></canvas>

  <script>
    /*****************************************************************
     * Basic chain reaction game implementation.
     *****************************************************************/

    // Set the grid dimensions.
    const rows = 9;
    const cols = 6;
    // Define the size (in pixels) for each cell.
    const cellWidth = 80;
    const cellHeight = 80;

    // Colors for player 1 and player 2.
    const playerColors = {
      1: "red",
      2: "blue"
    };

    // Global game variables.
    let board = []; // 2D array: each cell is { count, owner }.
    let currentPlayer = 1; // Player 1 always starts.
    let gameOver = false;
    let processingChain = false;
    // Flags to ensure that a player is “active” only after making a move.
    const playerActive = {1: false, 2: false};

    // Get the canvas and set its dimensions.
    const canvas = document.getElementById("boardCanvas");
    canvas.width = cols * cellWidth;
    canvas.height = rows * cellHeight;
    const ctx = canvas.getContext("2d");

    // Initialize the board with empty cells.
    function initBoard() {
      board = [];
      for (let r = 0; r < rows; r++) {
        const row = [];
        for (let c = 0; c < cols; c++) {
          row.push({ count: 0, owner: 0 }); // owner === 0 means empty.
        }
        board.push(row);
      }
    }

    // Calculate the explosion threshold for a given cell.
    // (A cell’s threshold is the number of its valid (orthogonal) neighbors.)
    function getThreshold(r, c) {
      let threshold = 4;
      if (r === 0 || r === rows - 1) threshold--;
      if (c === 0 || c === cols - 1) threshold--;
      return threshold;
    }

    // Draw the grid, border lines, and orbs in each cell.
    function drawBoard() {
      // Clear canvas.
      ctx.clearRect(0, 0, canvas.width, canvas.height);

      // Draw grid lines.
      ctx.strokeStyle = "#777";
      for (let r = 0; r <= rows; r++) {
        ctx.beginPath();
        ctx.moveTo(0, r * cellHeight);
        ctx.lineTo(canvas.width, r * cellHeight);
        ctx.stroke();
      }
      for (let c = 0; c <= cols; c++) {
        ctx.beginPath();
        ctx.moveTo(c * cellWidth, 0);
        ctx.lineTo(c * cellWidth, canvas.height);
        ctx.stroke();
      }

      // Draw the orbs in each cell.
      for (let r = 0; r < rows; r++) {
        for (let c = 0; c < cols; c++) {
          const cell = board[r][c];
          if (cell.count > 0) {
            drawOrbs(r, c, cell.count, cell.owner);
          }
        }
      }
    }

    // Helper function: Draw orbs in a cell at row r and column c.
    // We position them depending on how many are in the cell.
    function drawOrbs(r, c, count, owner) {
      const centerX = c * cellWidth + cellWidth / 2;
      const centerY = r * cellHeight + cellHeight / 2;
      const radius = 10;
      const color = playerColors[owner];

      const positions = [];
      if (count === 1) {
        positions.push({ x: centerX, y: centerY });
      } else if (count === 2) {
        positions.push({ x: centerX - radius, y: centerY });
        positions.push({ x: centerX + radius, y: centerY });
      } else if (count === 3) {
        positions.push({ x: centerX - radius, y: centerY - radius });
        positions.push({ x: centerX + radius, y: centerY - radius });
        positions.push({ x: centerX, y: centerY + radius });
      } else {
        // (For safety, if more than 3 orbs ever show up.)
        for (let i = 0; i < count; i++) {
          const angle = (2 * Math.PI * i) / count;
          positions.push({
            x: centerX + radius * Math.cos(angle),
            y: centerY + radius * Math.sin(angle)
          });
        }
      }

      ctx.fillStyle = color;
      positions.forEach(pos => {
        ctx.beginPath();
        ctx.arc(pos.x, pos.y, radius, 0, 2 * Math.PI);
        ctx.fill();
      });
    }

    // Process chain reactions. This function looks for cells that have reached
    // or exceeded their threshold and “explodes” them, sending one orb to each
    // neighbor. The explosions are processed in steps to allow simple animation.
    function processChainReaction() {
      const unstable = [];
      // Find unstable cells.
      for (let r = 0; r < rows; r++) {
        for (let c = 0; c < cols; c++) {
          if (board[r][c].count >= getThreshold(r, c)) {
            unstable.push({ r, c, owner: board[r][c].owner });
          }
        }
      }
      // If none are unstable, finish the chain reaction.
      if (unstable.length === 0) {
        processingChain = false;
        drawBoard();
        checkWin();
        if (!gameOver) {
          // Switch turn after chain reactions have completely subsided.
          currentPlayer = currentPlayer === 1 ? 2 : 1;
          updateInfo();
        }
        return;
      }
      processingChain = true;
      // Process all unstable cells simultaneously.
      const additions = [];
      unstable.forEach(item => {
        const { r, c, owner } = item;
        // Reset the unstable cell.
        board[r][c].count = 0;
        board[r][c].owner = 0;
        // Get valid adjacent cell coordinates.
        const directions = [
          { dr: -1, dc: 0 },
          { dr: 1, dc: 0 },
          { dr: 0, dc: -1 },
          { dr: 0, dc: 1 }
        ];
        directions.forEach(dir => {
          const nr = r + dir.dr;
          const nc = c + dir.dc;
          if (nr >= 0 && nr < rows && nc >= 0 && nc < cols) {
            additions.push({ r: nr, c: nc, owner });
          }
        });
      });
      // Apply additions: increase orb count and change ownership.
      additions.forEach(add => {
        board[add.r][add.c].count++;
        // When an orb is added, the cell converts to the explosion owner.
        board[add.r][add.c].owner = add.owner;
      });
      drawBoard();
      // Continue the chain reaction after a short delay.
      setTimeout(processChainReaction, 200);
    }

    // Check whether one of the players has lost (after both have played at least once).
    function checkWin() {
      const counts = { 1: 0, 2: 0 };
      for (let r = 0; r < rows; r++) {
        for (let c = 0; c < cols; c++) {
          const owner = board[r][c].owner;
          if (owner !== 0) {
            counts[owner] += board[r][c].count;
          }
        }
      }
      if (playerActive[1] && playerActive[2]) {
        if (counts[1] === 0) {
          gameOver = true;
          alert("Player 2 wins!");
        } else if (counts[2] === 0) {
          gameOver = true;
          alert("Player 1 wins!");
        }
      }
    }

    // Update the info div with the current turn.
    function updateInfo() {
      document.getElementById("info").textContent = "Current Turn: Player " + currentPlayer;
    }

    // Handle player moves on canvas clicks.
    canvas.addEventListener("click", function(event) {
      if (gameOver || processingChain) return;
      const rect = canvas.getBoundingClientRect();
      const x = event.clientX - rect.left;
      const y = event.clientY - rect.top;
      const c = Math.floor(x / cellWidth);
      const r = Math.floor(y / cellHeight);
      // A valid move can only be played on an empty cell or one already owned by the current player.
      if (board[r][c].owner === 0 || board[r][c].owner === currentPlayer) {
        // Place an orb.
        board[r][c].count++;
        board[r][c].owner = currentPlayer;
        // Mark that the player is now active.
        playerActive[currentPlayer] = true;
        drawBoard();
        // Begin processing any chain reactions.
        processingChain = true;
        setTimeout(processChainReaction, 200);
      }
    });

    // Initialize the game.
    function initGame() {
      initBoard();
      updateInfo();
      drawBoard();
    }

    initGame();
  </script>
</body>
</html>
