<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>Modern Animated Chain Reaction</title>
  <style>
    body {
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            background-color: #1e1e1e;
    }
    #info {
      margin-bottom: 20px;
      font-size: 24px;
      color: white;
    }
    canvas {
      background: #2d2d2d;
      border: 2px solid #444;
      border-radius: 10px;
      box-shadow: 0 4px 15px rgba(0, 0, 0, 0.5);
    }
        .modern-button {
            background-color: #4CAF50;
            color: white;
            border: none;
            padding: 15px 30px;
            font-size: 16px;
            border-radius: 8px;
            cursor: pointer;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            transition: background-color 0.3s ease, transform 0.2s ease;
        }

        .modern-button:hover {
            background-color: #45a049;
            transform: translateY(-2px);
        }

        .modern-button:active {
            transform: translateY(1px);
        }
  </style>
</head>
<body>
  <div id="info">Current Turn: Player 1</div>
  <canvas id="boardCanvas"></canvas>

  <script>
    /*****************************************************************
     * Modern Animated Chain Reaction Game
     *
     * Two players take turns placing orbs on a grid. Each cell’s
     * critical mass is determined by its number of (orthogonal)
     * neighbors. When the orb count in a cell meets or exceeds
     * its threshold, the cell “explodes”—animated as smooth orb
     * movements—to adjacent cells, converting any opponent’s orbs.
     * The game ends once both players have played and one player's
     * orbs are entirely removed.
     *****************************************************************/

    // Grid configuration
    const rows = 9;
    const cols = 6;
    const cellWidth = 80;
    const cellHeight = 80;

    // Player colors in a modern palette.
    const playerColors = {
      1: "#ff4d4d", // red-ish
      2: "#4d94ff"  // blue-ish
    };

    // Global game state
    let board = [];         // 2D array: each cell { count, owner }
    let currentPlayer = 1;  // Player 1 begins.
    let gameOver = false;
    let processingChain = false;  // True while chain reactions are taking place.
    const playerActive = { 1: false, 2: false };

    // For smooth explosion animations: moving orbs are animated objects.
    let movingOrbs = [];

    // Add a global variable to track the rotation angle for revolving orbs.
    let rotationAngle = 0;

    // Set up the canvas (and its modern style) and graphics context.
    const canvas = document.getElementById("boardCanvas");
    canvas.width = cols * cellWidth;
    canvas.height = rows * cellHeight;
    const ctx = canvas.getContext("2d");

    // Easing function for smooth animations.
    function easeOutQuad(x) {
      return 1 - (1 - x) * (1 - x);
    }

    // Initialize the grid.
    function initBoard() {
      board = [];
      for (let r = 0; r < rows; r++) {
        let row = [];
        for (let c = 0; c < cols; c++) {
          row.push({ count: 0, owner: 0 });
        }
        board.push(row);
      }
    }

    // Determine a cell's explosion threshold based on its position.
    // Corners have threshold 2, edges 3, centers 4.
    function getThreshold(r, c) {
      let threshold = 4;
      if (r === 0 || r === rows - 1) threshold--;
      if (c === 0 || c === cols - 1) threshold--;
      return threshold;
    }

    // Draw the game board: grid lines, static orbs, and any moving orbs.
    function drawBoard() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);

      // Draw grid lines in a subtle modern style.
      ctx.strokeStyle = "#555";
      ctx.lineWidth = 1;
      for (let r = 0; r <= rows; r++) {
        ctx.beginPath();
        ctx.moveTo(0, r * cellHeight);
        ctx.lineTo(canvas.width, r * cellHeight);
        ctx.stroke();
      }
      for (let c = 0; c <= cols; c++) {
        ctx.beginPath();
        ctx.moveTo(c * cellWidth, 0);
        ctx.lineTo(c * cellWidth, canvas.height);
        ctx.stroke();
      }

      // Draw static orbs (already “at rest” in the cells).
      for (let r = 0; r < rows; r++) {
        for (let c = 0; c < cols; c++) {
          const cell = board[r][c];
          if (cell.count > 0) {
            drawOrbsInCell(r, c, cell.count, cell.owner);
          }
        }
      }

      // Draw moving explosion orbs on top.
      movingOrbs.forEach(orb => {
        drawOrbAt(orb.x, orb.y, orb.owner);
      });
    }

    // Update the drawOrbsInCell function to make orbs revolve around each other.
    function drawOrbsInCell(r, c, count, owner) {
  const centerX = c * cellWidth + cellWidth / 2;
  const centerY = r * cellHeight + cellHeight / 2;
  const baseRadius = 10;
  const orbitRadius = 12; // Closer orbs for virus-like clustering
  const color = playerColors[owner];
  ctx.fillStyle = color;

  // Breathing effect using sine wave
  const time = Date.now() * 0.005;
  const breathing = 1 + 0.2 * Math.sin(time);

  let positions = [];
  if (count === 1) {
    positions.push({ x: centerX, y: centerY });
  } else {
    for (let i = 0; i < count; i++) {
      const angle = (2 * Math.PI * i) / count + rotationAngle;
      positions.push({
        x: centerX + orbitRadius * Math.cos(angle),
        y: centerY + orbitRadius * Math.sin(angle),
      });
    }
  }

  positions.forEach(pos => {
    ctx.beginPath();
    ctx.arc(pos.x, pos.y, baseRadius * breathing, 0, 2 * Math.PI);
    ctx.fill();
  });
}


    // Draw a single orb at a specified (x,y) coordinate.
    function drawOrbAt(x, y, owner) {
      const radius = 10;
      ctx.fillStyle = playerColors[owner];
      ctx.beginPath();
      ctx.arc(x, y, radius, 0, 2 * Math.PI);
      ctx.fill();
    }

    // When a cell explodes, create moving orb animations destined
    // for each valid (orthogonal) neighbor.
    function startExplosion(r, c) {
      const owner = board[r][c].owner;
      // Clear the exploding cell.
      board[r][c].count = 0;
      board[r][c].owner = 0;

      // Define neighbor directions: up, down, left, right.
      const directions = [
        { dr: -1, dc: 0 },
        { dr: 1, dc: 0 },
        { dr: 0, dc: -1 },
        { dr: 0, dc: 1 }
      ];

      directions.forEach(dir => {
        const nr = r + dir.dr;
        const nc = c + dir.dc;
        if (nr >= 0 && nr < rows && nc >= 0 && nc < cols) {
          // Create a moving orb from the center of the current cell
          // to the center of the neighbor cell.
          const orb = {
            startX: c * cellWidth + cellWidth / 2,
            startY: r * cellHeight + cellHeight / 2,
            endX: nc * cellWidth + cellWidth / 2,
            endY: nr * cellHeight + cellHeight / 2,
            owner: owner,
            progress: 0,
            duration: 300, // milliseconds
            x: c * cellWidth + cellWidth / 2,
            y: r * cellHeight + cellHeight / 2
          };
          movingOrbs.push(orb);
        }
      });
    }

    // Look for cells that have reached/exceeded their threshold.
    // If found, trigger their explosions. Otherwise, finish the chain.
    function processChainReactionsIfAny() {
      let unstableCells = [];
      for (let r = 0; r < rows; r++) {
        for (let c = 0; c < cols; c++) {
          if (board[r][c].count >= getThreshold(r, c)) {
            unstableCells.push({ r, c });
          }
        }
      }
      if (unstableCells.length > 0) {
        unstableCells.forEach(cell => startExplosion(cell.r, cell.c));
      } else {
        // No more unstable cells: chain reaction complete.
        processingChain = false;
        checkWin();
        if (!gameOver) {
          // Switch turns after chain reactions settle.
          currentPlayer = currentPlayer === 1 ? 2 : 1;
          updateInfo();
        }
      }
    }

    // Update moving orb animations. As each orb travels, update its
    // position using an easing function. When an orb reaches its
    // destination, add it to the target cell.
    function updateMovingOrbs(dt) {
      // dt is in milliseconds.
      for (let i = movingOrbs.length - 1; i >= 0; i--) {
        let orb = movingOrbs[i];
        orb.progress += dt;
        let t = Math.min(orb.progress / orb.duration, 1);
        let easeT = easeOutQuad(t);
        orb.x = orb.startX + (orb.endX - orb.startX) * easeT;
        orb.y = orb.startY + (orb.endY - orb.startY) * easeT;

        if (t >= 1) {
          // Orb has reached its destination.
          movingOrbs.splice(i, 1);
          let destC = Math.floor(orb.endX / cellWidth);
          let destR = Math.floor(orb.endY / cellHeight);
          board[destR][destC].count++;
          board[destR][destC].owner = orb.owner;
        }
      }
    }

    // Check win conditions once both players have activated.
    function checkWin() {
      const counts = { 1: 0, 2: 0 };
      for (let r = 0; r < rows; r++) {
        for (let c = 0; c < cols; c++) {
          const owner = board[r][c].owner;
          if (owner !== 0) {
            counts[owner] += board[r][c].count;
          }
        }
      }
      if (playerActive[1] && playerActive[2]) {
        if (counts[1] === 0) {
          gameOver = true;
          setTimeout(() => alert("Player 2 wins!"), 100);
        } else if (counts[2] === 0) {
          gameOver = true;
          setTimeout(() => alert("Player 1 wins!"), 100);
        }
      }
    }

    // Update the info display to show whose turn it is.
    function updateInfo() {
      document.getElementById("info").textContent = "Current Turn: Player " + currentPlayer;
    }

    // Handle canvas clicks: if the clicked cell is empty or belongs to
    // the current player, add an orb and trigger (animated) chain reactions.
    canvas.addEventListener("click", function(event) {
      if (gameOver || processingChain) return;
      const rect = canvas.getBoundingClientRect();
      const x = event.clientX - rect.left;
      const y = event.clientY - rect.top;
      const c = Math.floor(x / cellWidth);
      const r = Math.floor(y / cellHeight);
      if (board[r][c].owner === 0 || board[r][c].owner === currentPlayer) {
        board[r][c].count++;
        board[r][c].owner = currentPlayer;
        playerActive[currentPlayer] = true;
        // Begin processing any chain reactions.
        processingChain = true;
      }
    });

    // The main animation loop uses requestAnimationFrame for smooth updates.
    let lastTimestamp = 0;
    // Update the game loop to increment the rotation angle for animation.
    function gameLoop(timestamp) {
      if (!lastTimestamp) lastTimestamp = timestamp;
      const dt = timestamp - lastTimestamp;
      lastTimestamp = timestamp;

      // Increment the rotation angle for the revolving effect.
      rotationAngle += 0.01;

      updateMovingOrbs(dt);
      // If no moving orbs remain and chain reactions are flagged,
      // check for unstable cells to process.
      if (processingChain && movingOrbs.length === 0) {
        processChainReactionsIfAny();
      }
      drawBoard();
      requestAnimationFrame(gameLoop);
    }

    function initGame() {
      initBoard();
      updateInfo();
      requestAnimationFrame(gameLoop);
    }

    initGame();
  </script>

    <div>
      <button class="modern-button" onclick="restartGame()">Restart</button>
    </div>
    <script>

        function restartGame() {
            location.reload();
        }
    </script>
    </body>
    
</html>
